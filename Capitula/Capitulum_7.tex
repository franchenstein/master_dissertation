\chapter{Results}\label{cap:4}


{\lettrine[loversize=0.25,findent=0.2em,nindent=0em]{I}{n} this chapter, the efficiency of the algorithms proposed in Chapter 3 to construct a PFSA is verified for some examples of dynamic systems that can be represented by a PFSA. Results for more practical and complex systems are discussed in the next chapter. First, from the original system, a discrete sequence \textit{S} over the alphabet $\Sigma$ of length \textit{N}$=10^7$ is generated. Then, we calculate the probabilities of subsequences occurring in \textit{S} up to a length \textit{L}$_{max}$ and construct an RTP from these probabilities. After this, a series of PFSA are created using the D-Markov Machine, CRISSiS and the ALEPH algorihm with different values of their parameters, that is, $D$ (for D-Markov Machines), $L$ (for the ALEPH algorithms) and $L_2$ (for CRISSiS). Finally, the accuracy of each of those PFSA are compared using the metrics explained in Section \ref{sec:metrics} and the comparison results are explained in Section \ref{sec:testcases}.

\section{Evaluation Metrics}\label{sec:metrics}
%
%\subsection{Number of States}
%
%This is the simplest comparison parameter. Each PFSA generated by the algorithms will have a set of states \textit{Q} of size |\textit{Q}|. When the original PFSA is known, it is useful to compare if the generated PFSA has a number of states close to the original. When that is not the case and all that is known is the original sequence, ideally it would be better to have a smaller PFSA to model the system. But there might be a trade-off where the smaller PFSA will result in the other metrics described in the following sections are deteriorated, while a bigger and more complex model achieves better performance. But given similar performances, the best model is the one with less states.

This section presents the three metrics that will be used to compare the performance of the PFSA generated by the algorithms. The first one is the conditional entropy that is used to approximate the entropy rate, which gives a sense of the memory of the system. The two other metrics, the Kullback-Leibler Divergence and $\Phi$, compare sequences generated by the models with the original one and estimate how similar they are. The lower these metrics are, the more similar to the original system are the models.

\subsection{Entropy Rate}

%In Information Theory, entropy is a measure of the average information contained in a system. Using the definition in \cite{cover2012elements} and \citep{asok.14}, the Conditional Entropy is given by:
%
%\begin{equation}
%H(X|Y) \triangleq -\sum_{x\in X}P(x|Y)\log P(x|Y) . \label{eq:condent}
%\end{equation}

Let $\{X_k\}_{k=1}^{\infty}$ be a discrete random process over $\Sigma$. Its entropy rate is defined as \cite{cover2012elements}:

\begin{equation}
h \triangleq \lim_{k\rightarrow\infty}H(X_k|X_1X_2\ldots X_{k-1}) = -\lim_{k\rightarrow\infty}\sum_{x\in \Sigma^k}\Pr(x)\log \Pr(x_k|x_1x_2\ldots x_{k-1}).  \label{eq:entrate}
\end{equation}

\noindent For a stationary process, the conditional entropy $H(X_k|X_1\ldots X_{k-1})$ is non-increasing in $k$ and converges to $h$ as $k$ approaches infinity \citep{cover2012elements}. As it is not feasible to compute (\ref{eq:entrate}) up to infinity when the distribution is know only up to $L_{max}$, we use the $\ell$-order conditional entropy defined as:

\begin{equation}
h_{\ell} \triangleq H(X_{\ell}|X_1X_2\ldots X_{\ell-1}),   \label{eq:entratel}
\end{equation}

\noindent which measures the uncertainty of a random variable $X_{\ell}$ given the previous $\ell$ samples.  The comparison of  $h_{\ell}$ of the generated PFSA with the one from the original system is useful to test if the generated one correctly captures the system memory.

\subsection{Kullback-Leibler Divergence}\label{sec:kld}

%The Kullback-Leibler Divergence is a method to compare the distance between two probability distributions \textit{P} and \textit{Q}. Its formula is given by:
%
%\begin{equation}
%D(P||Q) = \sum_{i}P(i)\log(\frac{P(i)}{Q(i)}).	\label{eq:kld}
%\end{equation}

For the purpose of comparing the algorithms, consider two sequences $S_1$ and $S_2$ over a common alphabet $\Sigma$. They can be either the original sequence $S$ or a sequence generated by a PFSA. Let $\omega\in\Sigma^{\ell}$ be a word of length $\ell$ and $P_1(\omega)$ and $P_2(\omega)$ are the probabilities of occurrence of $\omega$ in $S_1$ and $S_2$ respectively. For a given $\ell$ we take the $\ell$-order Kullback-Leibler Divergence as: 

\begin{equation}
D_{\ell}(S_1||S_2) = \sum_{\omega\in\Sigma^{\ell}}P_1(\omega)\log\Big(\frac{P_1(\omega)}{P_2(\omega)}\Big).	\label{eq:kldl}
\end{equation}

\noindent Although it is technically not a distance, as it does not obey the triangle inequality nor is necessarily commutative, the Kullback-Leibler Divergence is useful to give an idea of how similar two distributions are. A small divergence indicates that the sequence generated by a PFSA is statistically close to the original sequence, which shows that the PFSA is a good estimate for the original system.

%\subsection{$\Phi$-Metric}
%
%The $\Phi$-Metric is presented in \citep{asok.14} as a way to compare sequences. Given two sequences $S_1$ and $S_2$ over a common alphabet $\Sigma$ (again, these can be either the original sequence or a sequence generated by a PFSA) and  $\textbf{P}_1(\Sigma^j)$ and $\textbf{P}_2(\Sigma^j)$ are the vectors of probabilities of occurrences of each sequence in $\Sigma^j$ in $S_1$ and $S_2$ respectively. For example, for a binary alphabet $\textbf{P}_1(\Sigma^2) = [P_1(00), P_1(01), P_1(10), P_1(11)]$ with $P_1$ defined as in Section \ref{sec:kld}. The $\Phi$-Metric is then defined as:
%
%\begin{equation}
%\Phi(S_1, S_2) \triangleq \lim_{n\rightarrow\infty} \sum_{j = 1}^n \frac{\Vert \textbf{P}_1(\Sigma^j)-\textbf{P}_2(\Sigma^j)\Vert_{\ell_1}}{2^{j + 1}},\label{eq:phi}
%\end{equation}
%
%\noindent where $\Vert\star\Vert_{\ell_1}$ indicates the sum of absolute values of the elements in the vector $\star$. As (\ref{eq:phi}) puts more weight in shorter words, it can be truncated with a relatively small $\ell$. The $\ell$-order $\Phi$-Metric is:
%
%\begin{equation}
%\Phi_{\ell}(K1, K2) \triangleq \sum_{j = 1}^{\ell} \frac{\Vert\textbf{P}_1(\Sigma^j)-\textbf{P}_2(\Sigma^j)\Vert_{\ell_1}}{2^{j + 1}}.\label{eq:phil}
%\end{equation}
%
%\noindent As with the Kullback-Leibler Divergence, the $\Phi$-Metric compares two systems using sequences generated by them, taking the distribution of all sub-sequences up to length $\ell$. A small $\Phi$ indicates that the PFSA are similar to each other. For the performance comparison, each PFSA generated by the algorithms is compared with the original sequence using ($\ref{eq:phil}$) and the smaller the result, the better the algorithm models the original system.

\section{Construction of PFSA for Dynamic Systems}\label{sec:testcases}

We consider the following examples of dynamic systems with known representations as PFSA: the goal is to apply the D-Markov Machine, CRISSiS and ALEPH  algorithm to recover a good PFSA and compare their number of states.

In all examples, the ALEPH algorithm is able to recover the original PFSA for some value of $L$ as well as CRISSiS for some value of $L_2$.  Usually, D-Markov Machines are not capable of retrieving the original PFSA, but by increasing $D$, better machines are obtained in expense of an exponential growth in the number of states. The results for two D-Markov Machines are shown for each example: one for the $D$ that achieves a performance similar to the original PFSA and another for $D-1$ to show a more compact with lower performance.

In the following cases we consider $\ell=10$. All the PFSA were constructed using the $\chi^2$ test with $\alpha = 0.95$ and for the synchronization words, two values of $\alpha$ (0.95 and 0.99) were used.

\subsection{Ternary Even Shift}

The ternary even shift is a symbolic dynamic system with a ternary alphabet $\Sigma = \{0,1,2\}$ where there must be an even number of consecutive non-zero symbols between zeroes. A PFSA that satisfies this restriction is shown in Figure \ref{fig:ternaryeven}. 

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2 cm and 2 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (0)
{$0$};
\node[state] (1) [below left=of 0] {$1$};
\node[state] (2) [below right =of 0] {$2$};
\path (0) edge [loop above] node[above = 0.1 cm] {$0|0.5$} (0);
\path (0) edge [bend left = 15] node[below = 0.3 cm] {$1|0.25$} (1);
\path (0) edge [bend right = 15] node[below =0.3 cm] {$2|0.25$} (2);
\path (1) edge [bend left =15] node[above = 0.25 cm] {$1|1.0$} (0);
\path (2) edge [bend right =15] node[above =0.25 cm] {$2|1.0$} (0);
\end{tikzpicture}
\caption{A PFSA of a Ternary Even-Shift.\label{fig:ternaryeven}}
\end{figure}

The synchronization words found by our algorithm with $2 \leq W \leq 6$ are shown in Table \ref{tab:ternaryevensynch} for two values of $\alpha$ (0.95 and 0.99) and the same words ($\Omega_{syn} = \{0, 12, 21\}$) are found for any $W \geq 3$ . It is possible to check in the graph of Figure \ref{fig:ternaryeven} that all found synchronization words are indeed valid and each one synchronizes to one of state of the graph. They can all be used as starting points for the ALEPH algorithm.

\begin{table}
\centering
\caption{Synchronization Words for Ternary Even Shift. \label{tab:ternaryevensynch}}
\begin{tabular}{|l|c|c|}
\hline
 & \multicolumn{2}{c|}{$\alpha$}\\
 \hline
$W$ & 0.95 & 0.99 \\
\hline
2 & 0 & 0 \\ 
3 & 0, 12, 21 & 0, 12, 21 \\ 
4 & 0, 12, 21 & 0, 12, 21 \\ 
5 & 0, 12, 21 & 0, 12, 21 \\
6 & 0, 12, 21 & 0, 12, 21 \\
 \hline
\end{tabular}
\end{table}

The results of the ALEPH algorithm are compared to D-Markov and CRISSiS in Table \ref{tab:ternaryeven}. The ALEPH algorithm obtained the same results for any L greater than 2. D-Markov machines of $D = 8$ and $D = 9$ are considered. CRISSiS was tested using $L_2 = 1$. Both CRISSiS and ALEPH reconstruct the same PFSA (shown in Figure \ref{fig:ternaryevengen}) and are a good estimate to the original 3-state PFSA  while a large D-Markov machine with $D=9$ with 339 states is needed to obtain approximately the same performance. These D-Markov machines with $D=8$ and $9$ do not have $3^{8}$ and $3^{9}$ states respectively because there are forbidden words in the original system, which results in some states being non-existent in the RTP. The original system had $h_{10} = 1.0003$, which is close to the value found by all the algorithms.

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (0)
{$0$};
\node[state] (01) [below left=of 0] {$01$};
\node[state] (02) [below right =of 0] {$02$};
\path (0) edge [loop above] node[above = 0.1 cm] {$0|0.5001$} (0);
\path (0) edge [bend left = 15] node[below = 0.3 cm] {$1|0.2499$} (01);
\path (0) edge [bend right = 15] node[below =0.3 cm] {$2|0.2500$} (02);
\path (01) edge [bend left =15] node[above = 0.25 cm] {$1|1.0$} (0);
\path (02) edge [bend right =15] node[above =0.25 cm] {$2|1.0$} (0);
\end{tikzpicture}
\caption{PFSA of a Ternary Even-Shift generated by the ALEPH algorithm and by CRISSiS.\label{fig:ternaryevengen}}
\end{figure}

\begin{table}
\centering
\caption{Results for Ternary Even Shift. \label{tab:ternaryeven}}
\begin{tabular}{|l|c|c|c|}
\hline
 & \multicolumn{2}{c|}{D-Markov} & ALEPH/CRISSiS\\
 \hline
 & $D$ = 8 & $D$ = 9 &  $L$ = 2/$L_2$ = 1 \\
\hline
\# of States & 169 & 339 & 3 \\ 
$h_{10}$ & 1.0084 & 1.0058 & 1.0003 \\
$D_{10}$ & $2.7\cdot10^{-3}$ & $4.16\cdot10^{-5}$ & $9.55\cdot10^{-5}$ \\
%$\Phi_{10}$  & $2.1\cdot10^{-3}$ & $1.2\cdot10^{-3}$ & $2.3\cdot10^{-3}$ \\
 \hline
\end{tabular}
\end{table}

\subsection{Tri-Shift}

The Tri-Shift was previously discussed in Section \ref{sec:crissis} and a PFSA that represents it is shown in Figure \ref{fig:trishift}. The synchronization words found by the algorithm are shown in Table \ref{tab:trishiftsynch} and 00 appeared, as expected (see Section \ref{sec:crissis}), and 0110 synchronizes to the same state as 00, thus $\Omega_{syn} = \{00, 0110\}$. The comparative results are shown in Table \ref{tab:trishift}. Once again this is an example where our algorithm and CRISSiS are able to recover the three states from the original PFSA with a good estimate for the morphs as seen in Figure \ref{fig:trishiftgen}. To obtain a similar performance with a D-Markov machine, 256 states might be needed. The original system presented has $h_{10} = 0.4873$, showing that our algorithm, CRISSiS and the 8-Markov Machine are able to capture the system memory.

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2 cm and 2 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$A$};
\node[state] (B) [above right=of A] {$B$};
\node[state] (C) [below right =of B] {$C$};
\path (A) edge [loop left] node[above] {$0|0.5$} (A);
\path (A) edge [bend left = 15] node[above =0.35 cm] {$1|0.5$} (B);
\path (B) edge [bend left = 15] node[above =0.35 cm] {$0|0.8$} (C);
\path (B) edge [bend left = 15] node[below =0.35 cm] {$1|0.2$} (A);
\path (C) edge [loop right] node[above] {$1|0.3$} (C);
\path (C) edge [bend left = 15] node[below =0.15 cm] {$0|0.7$} (A);
\end{tikzpicture}
\caption{The Tri-Shift PFSA.\label{fig:trishift_again}}
\end{figure}

\begin{table}
\centering
\caption{Synchronization Words for Tri-Shift. \label{tab:trishiftsynch}}
\begin{tabular}{|l|c|c|}
\hline
 & \multicolumn{2}{c|}{$\alpha$}\\
 \hline
$W$ & 0.95 & 0.99 \\
\hline
2 & None & None \\ 
3 & 00 & 00 \\ 
4 & 00 & 00 \\ 
5 & 00, 0110 & 00, 0110 \\
6 & 00, 0110 & 00, 0110 \\
 \hline
\end{tabular}
\end{table}


\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$00$};
\node[state] (B) [above right=of A] {$001$};
\node[state] (C) [below right =of B] {$0010$};
\path (A) edge [loop left] node[above = 0.35cm] {$0|0.50002$} (A);
\path (A) edge [bend left = 15] node[above =0.35 cm] {$1|0.49998$} (B);
\path (B) edge [bend left = 15] node[above =0.35 cm] {$0|0.80002$} (C);
\path (B) edge [bend left = 15] node[below =0.45 cm] {$1|0.19998$} (A);
\path (C) edge [loop right] node[above = 0.35 cm] {$1|0.30007$} (C);
\path (C) edge [bend left = 15] node[below =0.15 cm] {$0|0.69993$} (A);
\end{tikzpicture}
\caption{The Tri-Shift PFSA generated by our algorithm and by CRISSiS.\label{fig:trishiftgen}}
\end{figure}

\begin{table}
\centering
\caption{Results for the Tri-Shift. \label{tab:trishift}}
\begin{tabular}{|l|c|c|c|}
\hline
 & \multicolumn{2}{c|}{D-Markov} & ALEPH/CRISSiS\\
 \hline
 & $D=7$ & $D=8$ & $L=4/L_2=1$ \\
\hline
\# of States & 128 & 256 & 3 \\ 
$h_{10}$ & 0.4870 & 0.4867 & 0.4872 \\
$D_{10}$ & $4.1\cdot10^{-3}$ & $1.65\cdot10^{-3}$ & $1.16\cdot10^{-3}$ \\
%$\Phi_{10}$ & $2.1\cdot10^{-3}$ & $7.2\cdot10^{-4}$ & $8.2\cdot10^{-4}$ \\
 \hline
\end{tabular}
\end{table}

\subsection{A Six-State PFSA}

Figure \ref{fig:sixstate} shows a PFSA with six states that shows how CRISSiS might need $L_2 \geq 1$ to retrieve the original machine. This system has 4 synchronization words: 00, 01, 10 and 1111, as shown in Table \ref{tab:tswsynch}. The comparative results between the algorithms is shown in Table \ref{tab:sixstate}.

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$A$};
\node[state] (B) [below left=of A] {$B$};
\node[state] (C) [below right =of A] {$C$};
\node[state] (D) [below =of B] {$D$};
\node[state] (E) [below =of C] {$E$};
\node[state] (F) [below right =of D] {$F$};
\path (A) edge [loop above] node[above = 0.15cm] {$0|0.9$} (A);
\path (A) edge node[right = 0.15 cm] {$1|0.1$} (C);
\path (C) edge node[right = 0.15 cm] {$1|1.0$} (E);
\path (E) edge node[right = 0.15 cm] {$1|1.0$} (F);
\path (F) edge node[left = 0.15 cm] {$1|1.0$} (D);
\path (D) edge node[left = 0.15 cm] {$0|1.0$} (B);
\path (B) edge node[left =0.15 cm] {$0|0.5$} (A);
\path (B) edge node[below =0.15 cm] {$1|0.5$} (C);
\end{tikzpicture}
\caption{A Six-State PFSA.\label{fig:sixstate}}
\end{figure}

\begin{table}
\centering
\caption{Synchronization Words for the Six-State PFSA. \label{tab:tswsynch}}
\begin{tabular}{|l|c|c|}
\hline
 & \multicolumn{2}{c|}{$\alpha$}\\
 \hline
$W$ & 0.95 & 0.99 \\
\hline
2 & None & None \\ 
3 & 00, 01, 10  & 00, 01, 10 \\ 
4 & 00, 01, 10  & 00, 01, 10 \\ 
5 & 00, 01, 10, 1111  & 00, 01, 10, 1111 \\
6 & 00, 01, 10, 1111  & 00, 01, 10, 1111 \\
 \hline
\end{tabular}
\end{table}

Using CRISSiS with $L_2$ larger than 3 and ALEPH with $L$ larger than 4, it is possible to reconstruct a good estimate to the original system, shown in Figure \ref{fig:sixstatealgo}. For a D-Markov Machine to perform similarly, it is necessary to use $D=4$, obtaining a PFSA with 11 states. Once again, some sequences do not occur, therefore the D-Markov Machine in those cases will not have $2^D$ states.

\begin{table}
\centering
\caption{Results for the Six-State PFSA. \label{tab:sixstate}}
\begin{tabular}{|l|c|c|c|}
\hline
 & \multicolumn{2}{c|}{D-Markov} & ALEPH/CRISSiS \\
 \hline
 & $D=3$ & $D=4$ & $L=4$/$L_2=3$ \\
\hline
\# of States & 7 & 11 & 6 \\ 
$h_{10}$ & 0.5341 & 0.3344 & 0.3344 \\
$D_{10}$ & 1.1980 & $4.0499\cdot 10^{-6}$ &  $5.6969\cdot10^{-5}$ \\
%$\Phi_{10}$ & $2.0005\cdot 10^{-3}$ & $4.6072\cdot 10^{-4}$ & $9.3745\cdot10^{-4}$ \\
 \hline
\end{tabular}
\end{table}

%The results for this system show a type of system where CRISSiS might nor perform so well. Starting from a single synchronization word and as many states have equal morphs and their paths will only be different after 3 steps, $L_2$ needs to be at least 3 to be able to recover the original PFSA and as CRISSiS' complexity is exponential on $L_2$ this means a considerable penalty in performance. 

As ALEPH uses all synchronization words, there are multiple starting points and the graph minimization algorithm step by the end is useful to differentiate states that will have different follower sets. The original system has a $h_{10} = 0.3344$, showing that both the 4-Markov Machine, the ALEPH algorithm and CRISSiS are able to estimate the PFSA with good precision.

%\begin{figure}
%\centering
%\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
%semithick ,
%state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
%\node[state] (A)
%{$00$};
%\node[state] (B) [right=of A] {$001$};
%\path (A) edge [loop left] node[left = 0.15cm] {$0|0.9001$} (A);
%\path (A) edge node[above = 0.15 cm] {$1|0.0999$} (B);
%\path (B) edge [loop right] node[right = 0.15 cm] {$1|1.0$} (B);
%\end{tikzpicture}
%\caption{The Recovered Six-State PFSA by CRISSiS with $L_2 = 1$.\label{fig:sixstatecrissis}}
%\end{figure}

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$00$};
\node[state] (B) [below left=of A] {$10$};
\node[state] (C) [below right =of A] {$01$};
\node[state] (D) [below =of B] {$1111$};
\node[state] (E) [below =of C] {$011$};
\node[state] (F) [below right =of D] {$0111$};
\path (A) edge [loop above] node[above = 0.15cm] {$0|0.9001$} (A);
\path (A) edge node[right = 0.15 cm] {$1|0.0999$} (C);
\path (C) edge node[right = 0.15 cm] {$1|1.0$} (E);
\path (E) edge node[right = 0.15 cm] {$1|1.0$} (F);
\path (F) edge node[left = 0.15 cm] {$1|1.0$} (D);
\path (D) edge node[left = 0.15 cm] {$0|1.0$} (B);
\path (B) edge node[left =0.15 cm] {$0|0.5001$} (A);
\path (B) edge node[below =0.15 cm] {$1|0.4999$} (C);
\end{tikzpicture}
\caption{The Recovered Six-State PFSA by our algorithm.\label{fig:sixstatealgo}}
\end{figure}

\subsection{Maximum Entropy $(d,k)$-Constrained Code}

As seen in \cite{immink.98}, a $(d,k)$-constrained code is a code used in digital recording devices and other systems in which a long sequences of 1's might cause desynchronization issues. This code guarantees that at most $k$ 1's are generated between occurrences of 0's. A Maximum Entropy $(d,k)$-Constrained Code is a PFSA that generates sequences with those restrictions and that also have maximum entropy rate. The algorithms are tested to recover a Maximum Entropy (3,5)-Constrained Code PFSA shown in Figure \ref{fig:dk_35}. The synchronization words for this system are 0 and 11111, as shown in Table \ref{tab:dk35synch}.

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$A$};
\node[state] (B) [right =of A] {$B$};
\node[state] (C) [right =of B] {$C$};
\node[state] (D) [right =of C] {$D$};
\node[state] (E) [right =of D] {$E$};
\node[state] (F) [right =of E] {$F$};
\path (A) edge node[below = 0.15cm] {$1|1.0$} (B);
\path (B) edge node[below = 0.15 cm] {$1|1.0$} (C);
\path (C) edge node[below = 0.15 cm] {$1|1.0$} (D);
\path (D) edge node[below = 0.15 cm] {$1|0.5902$} (E);
\path (D) edge [bend right] node[below = 0.15 cm] {$0|0.4908$} (A);
\path (E) edge node[below = 0.15 cm] {$1|0.4445$} (F);
\path (E) edge [bend right] node[right =1.75 cm] {$0|0.5555$} (A);
\path (F) edge [bend right] node[right =2.5 cm] {$0|1.0$} (A);
\end{tikzpicture}
\caption{The Maximum Entropy (3,5)-Constrained Code PFSA.\label{fig:dk_35}}
\end{figure}

\begin{table}
\centering
\caption{Synchronization Words for the Maximum Entropy (3,5)-Constrained Code. \label{tab:dk35synch}}
\begin{tabular}{|l|c|c|}
\hline
 & \multicolumn{2}{c|}{\textbf{$\alpha$}}\\
 \hline
$W$ & 0.95 & 0.99 \\
\hline
2 & 0 & 0 \\ 
3 & 0 & 0 \\ 
4 & 0 & 0 \\ 
5 & 0  & 0 \\
6 & 00, 11111  & 00, 11111 \\
7 & 00, 11111  & 00, 11111 \\
 \hline
\end{tabular}
\end{table}

The results for this system are shown in Table \ref{tab:dk35}. This is a practical case where CRISSiS needs $L_2 \geq 3$ to obtain a correct estimate. When $L_2$ is 3, CRISSiS recovers the same PFSA as the ALEPH algorithm with $L=6$ (shown in Figure \ref{fig:dk_35r}). The original $h_{10}$ is 0.3218. For a D-Markov Machine to have a similarly good performance, a $D$ of 5 is needed, generating machines with 7 states, which is larger than the original PFSA.

\begin{table}
\centering
\caption{Results for the Maximum Entropy (3,5)-Constrained Code PFSA. \label{tab:dk35}}
\begin{tabular}{|l|c|c|c|}
\hline
 & \multicolumn{2}{c|}{D-Markov} & CRISSiS/ALEPH \\
 \hline
 & $D=4$ & $D=5$ & $L_2=3$/$L=6$\\
\hline
\# of States & 5 & 7 & 6 \\ 
$h_{10}$ & 0.3575 & 0.3218 &  0.3218 \\
$D_{10}$ & 0.1793 & $7.0139\cdot 10^{-7}$ & $5.9715\cdot 10^{-7}$\\
%$\Phi_{10}$ & $5.0521\cdot 10^{-3}$ & $2.8001\cdot 10^{-4}$ & $9.3656\cdot 10^{-5}$ \\
 \hline
\end{tabular}
\end{table}

\begin{figure}
\centering
\begin {tikzpicture}[-latex ,auto ,node distance =2.7 cm and 2.7 cm ,on grid ,
semithick ,
state/.style ={ circle , draw = black , text=black , minimum width =1 cm}]
\node[state] (A)
{$0$};
\node[state] (B) [right =of A] {$01$};
\node[state] (C) [right =of B] {$011$};
\node[state] (D) [right =of C] {$0111$};
\node[state] (E) [right =of D] {$01111$};
\node[state] (F) [right =of E] {$11111$};
\path (A) edge node[below = 0.15cm] {$1|1.0$} (B);
\path (B) edge node[below = 0.15 cm] {$1|1.0$} (C);
\path (C) edge node[below = 0.15 cm] {$1|1.0$} (D);
\path (D) edge node[below = 0.15 cm] {$1|0.5902$} (E);
\path (D) edge [bend right] node[below = 0.15 cm] {$0|0.4908$} (A);
\path (E) edge node[below = 0.15 cm] {$1|0.4437$} (F);
\path (E) edge [bend right] node[right =1.75 cm] {$0|0.5563$} (A);
\path (F) edge [bend right] node[right =2.5 cm] {$0|1.0$} (A);
\end{tikzpicture}
\caption{The Maximum Entropy (3,5)-Constrained Code PFSA recovered by ALEPH algorithm and by CRISSiS.\label{fig:dk_35r}}
\end{figure}
