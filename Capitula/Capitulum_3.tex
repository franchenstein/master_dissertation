\chapter{Algorithms Descriptions}\label{cap:3}

\tikzset{
  treenode/.style = {shape=circle,
                     draw, align=center,
                     top color=white},
  root/.style     = {treenode, font=\ttfamily\normalsize},
  env/.style      = {treenode, font=\ttfamily\normalsize},
  leaf/.style    = {treenode,font=\ttfamily\normalsize, bottom color=red}
}


{\lettrine[loversize=0.25,findent=0.2em,nindent=0em]{N}{o}

\section{A New Algorithm for Finding Synchronization Words}

Given a sequence \textit{X} of length \textit{L} over an alphabet $\Sigma$ which is the output of a dynamical system, the proposed algorithm is an alternative to find possible synchronization words in \textit{X}. The typical method would be using Equation \ref{eq:practsynchword} and testing for all possible values.  The proposed algorithm will use data structures in order to speed up the process.

The algorithm uses two rooted tree with probabilities to search for synchronization words. The main tree $\mathcal{T}$ represents the statistics of sub-sequences of the original sequence \textit{X} and the auxiliary tree $\mathcal{S}$ is used to search the suffixes of those sub-sequences and keep track of their status as valid candidates for synchronization words. The auxiliary tree regulates how the main tree is explored while the search is performed. Once the expansion reaches its end, a list of the most likely synchronization words is returned.

A Rooted Tree with Probabilities $\mathcal{T}$ over $\Sigma = \{0, 1\}$ is presented via an example in figure \ref{fig:rtp}. $\mathcal{T}$ consists of a set of branching nodes $\mathcal{B}$ and a set of leaf nodes $\mathcal{L}$.  All nodes have exactly one predecessor (with the exception of the root node, which has no predecessors). Leaf nodes have no successors, while each branching node has $|\Sigma|$ successors as each element of $\Sigma$ labels one of the outgoing branches. Those branches are also labeled with the probability of leaving the node with that symbol. Each node is labeled with the string formed from concatenating the symbols in the branches in the path from the root to the current node. The root node is labeled with the empty string $\epsilon$. The probability of reaching a node is given by multiplying the probabilities labeling the branches in the path from the root node to the current node.

For example, the leaf node \textit{10} is labeled as so because to reach it, the path taken from the root node $\epsilon$ is first \textit{1} and then \textit{0}. The probability of reaching this node is $P(1)\times P(0|1)$, that is the probability of leaving the root node with 1 (which is $P(1)$) multiplied by the probability of leaving the node 1 with 0 (that is, $P(0|1$). 

\begin{figure}[h]
\centering
\begin{tikzpicture}
  [
    grow                    = right,
    sibling distance        = 3em,
    level distance          = 6em,
    edge from parent/.style = {draw, -latex},
    every node/.style       = {font=\footnotesize},
    sloped
  ]
  \node [root] {$\epsilon$}
    child { node [env] {1}
      child{ node [leaf] {11}
      	edge from parent node [below] {1/P(1$|$1)}}
      child{ node [leaf] {10}
      	edge from parent node [above] {0/P(0$|$1)}}
      edge from parent node [below] {1/P(1)} }
    child { node [leaf] {0}
      edge from parent node [above] {0/P(0)} };
\end{tikzpicture}
\caption{Example of a rooted tree with probabilities. \label{fig:rtp}}
\end{figure}

 The two rooted tree with probabilities used in the algorithm are $\mathcal{T}$ and $\mathcal{S}$. The primary tree $\mathcal{T}$ has branch probabilities taken from the conditional probabilities from the sequence. The auxiliary tree $\mathcal{S}$ is constructed from $\mathcal{T}$. Each node has a label that is the inverse from the node label in $\mathcal{T}$, but keeping the same branch probabilities. This is done in order to use the nodes in $\mathcal{S}$ to verify the suffixes of nodes in $\mathcal{T}$ as it is explained in an example. 

From these two trees, two dynamic lists are created. The list $\Delta$ is initialized with the root node from $\mathcal{T}$ and all of its children nodes. The elements in the second list $\Gamma$ are triples \textit{(s, candidacy, tested)}. \textit{s} is a state from $\mathcal{S}$ and the other two elements are binary flags. The \textit{candidacy flag} is checked true if the state \textit{s} is a valid candidate for synchronization word. The \textit{test flag} is checked true if \textit{s} have been through all the statistical tests to check its candidacy for synchronization word status.

\begin{definition}\label{definition:validstate}
A state \textit{s} from a rooted tree with probabilities $\mathcal{S}$ is called a valid state if the triple (s, candidacy, tested) in list $\Gamma$ has the candidacy flag set to true and the tested flag set to false. 
\end{definition}

From the this definition, a state is called valid when it is a valid candidate for a synchronization word, but its status is yet to be tested. Whenever a new element is added to $\Gamma$ it is added as a valid state. $\Gamma$ is initialized with the triple \textit{($\epsilon$, True, False)}, where $\epsilon$ is the root of $\mathcal{S}$ and, as stated before, it is initialized as a valid state. The function \textit{nextValidState} returns the valid state in $\Gamma$ with the shortest label.

The algorithm receives the parameter \textit{W} which indicates the maximum length of subsequences it will take into consideration, i.e. the depth of the tree $\mathcal{T}$. The depth of $\mathcal{S}$ is $W - 1$.
  
Figures \ref{fig:treet} and \ref{fig:trees} are used as examples. They are both taken over binary alphabet and with branch probabilities taken from a computer generated sequence. \textit{W} is taken to be equal to 3. $\mathcal{S}$ is constructed from $\mathcal{T}$ by taking the labels from each state and reversing them, while keeping the branch probabilities. To show how this is useful to find suffixes, take the node \textit{110} from $\mathcal{T}$, reverse it (obtaining \textit{011}) and walk through $\mathcal{S}$. Starting at $\epsilon$, the walk goes through \textit{0} and then \textit{01}. Reverting each visited state, it is seen that $\epsilon$, \textit{0} and \textit{10} are suffixes of \textit{110}, as it was expected.
  
\begin{figure}[h]
\centering
\tikzstyle{level 1}=[level distance=3cm, sibling distance=4.5cm]
\tikzstyle{level 2}=[level distance=4cm, sibling distance=2.5cm]
\tikzstyle{level 3}=[level distance=4cm, sibling distance=1cm]
\begin{tikzpicture}
	[
    grow = right,
    edge from parent/.style = {draw, -latex},
    every node/.style       = {font=\footnotesize},
    sloped    
    ]
  \node [root] {$\epsilon$}
    child { node [env] {1}
      child{ node [env] {11}
      	child{ node [leaf] {111}
        	edge from parent node [below] {1/$P(1|11)$}}
      	child{ node [leaf] {110}
        	edge from parent node [above] {0/$P(0|11)$}}
      	edge from parent node [below] {1/P(1$|$1)}}
      child{ node [env] {10}
      	child{ node [leaf] {101}
        	edge from parent node [below] {1/$P(1|10)$}}
      	child{ node [leaf] {100}
        	edge from parent node [above] {0/$P(0|10)$}}
      	edge from parent node [above] {0/P(0$|$1)}}
      edge from parent node [below] {1/P(1)} }
    child { node [env] {0}
      child{ node [env] {01}
       	child{ node [leaf] {011}
         	edge from parent node [below] {1/$P(1|01)$}}
       	child{ node [leaf] {010}
         	edge from parent node [above] {0/$P(0|01)$}}
      	edge from parent node [below] {1/P(1$|$0)}}
      child{ node [env] {00}
       	child{ node [leaf] {001}
         	edge from parent node [below] {1/$P(1|00)$}}
       	child{ node [leaf] {000}
         	edge from parent node [above] {0/$P(0|00)$}}
      	edge from parent node [above] {0/P(0$|$0)}}
      edge from parent node [above] {0/P(0)} };
\end{tikzpicture}
\caption{Example of binary $\mathcal{T}$ \label{fig:treet}}
\end{figure}

\begin{figure}[h]
\centering
\tikzstyle{level 1}=[level distance=3cm, sibling distance=4.5cm]
\tikzstyle{level 2}=[level distance=4cm, sibling distance=2.5cm]
\tikzstyle{level 3}=[level distance=4cm, sibling distance=1cm]
\begin{tikzpicture}
  [
    grow                    = right,
    sibling distance        = 3em,
    level distance          = 6em,
    edge from parent/.style = {draw, -latex},
    every node/.style       = {font=\footnotesize},
    sloped
  ]
    \node [root] {$\epsilon$}
    child { node [env] {1}
      child{ node [leaf] {11}
      	edge from parent node [below] {1/P(1$|$1)}}
      child{ node [leaf] {01}
      	edge from parent node [above] {0/P(0$|$1)}}
      edge from parent node [below] {1/P(1)} }
    child { node [env] {0}
      child{ node [leaf] {10}
      	edge from parent node [below] {1/P(1$|$0)}}
      child{ node [leaf] {00}
      	edge from parent node [above] {0/P(0$|$0)}}
      edge from parent node [above] {0/P(0)} };
\end{tikzpicture}
\caption{Example of binary $\mathcal{S}$ \label{fig:trees}}
\end{figure}

When two morphs are compared as in $\mathcal{V}(q) = \mathcal{V}(p)$ it means that both of these distributions are being compared via an appropriate statistical test and this operation returns a true or false whether the test was successful or not for a predetermined confidence level $\alpha$.

To find the synchronization words, algorithm~\ref{alg:findsynchwords} is used. It receives as parameters both trees and \textit{W}. The lists $\Gamma$ and $\Delta$ are then created as described above. Besides that, the list $\Omega_{syn}$, which will receive the results from the algorithm, is initialized as an empty list.

At the start of each iteration, the function \textit{nextValidState} is applied to $\Gamma$ and returns the shortest valid candidate for synchronization word \textit{c}. If no valid states are found, $\Omega_{syn}$ will receive the labels of all elements in $\Gamma$ for which the candidacy flags are set to true. Given the tuple $\omega = (x_1, x_2, \ldots, x_t)$, the notation $\omega.x_i$ is used to denote the element $x_i$ from $\omega$. In other words, $\Omega_{syn}$ receives all elements $\gamma$ from $\Gamma$ for which $\gamma.candidacy$ is true. This list is then returned. As there are no valid states, this means that all possible states have been tested and the states which still have the candidacy flag set to true are the synchronization words to be returned.

If there is a valid state \textit{c}. If the label of \textit{c} is shorter than \textit{W}, another list $\Lambda$ is created with all the elements from $\Delta$ whose lengths are less than the length of \textit{c}. On the other hand, if it larger than the window size, this candidate is not taken into consideration.

Each element $\lambda$ of $\Lambda$ is then compared to \textit{c}. First, it is checked if \textit{c.label} is a suffix of $\lambda$. In the affirmative case, the label of \textit{c} and $\lambda$ are compared via a statistical test (usually the $\chi^2$ test as noted before).

If the test result is positive, the current candidate keeps its candidacy status and the algorithm keeps iterating. After \textit{c} is tested against all states from $\Lambda$ for which it is a suffix, the candidate is marked as tested.

On the other hand, if the test fails, $\Gamma$ and $\Delta$ are expanded via Algorithm \ref{alg:expand} and all states from $\Gamma$ are marked as untested as they will have to go through a new phase of testing with the new states that were added to the lists $\Gamma$ and $\Delta$ from the expansion.

This is a way of implementing Equation \ref{eq:practsynchword}. Each word is tested against all its possible suffixes in each iteration and if it still keeps the candidacy flag set to true, it is a synchronization word. The tree structure improves on the brute force method as no unnecessary tests will be performed for longer words if a shorter one is still valid.

\begin{algorithm} 
  \caption{findSynchWords($W, \mathcal{S}, \mathcal{T}$)\label{alg:findsynchwords}}
    \begin{algorithmic}[1]
      \Procedure{Initialization}{}
      	\State $\Gamma \gets \{(\epsilon,True,False)\}$ 
        \State $\Delta \gets \{\epsilon, \delta(\epsilon_T, \sigma)\text{ } \forall \sigma \in \Sigma\}$
        \State $\Omega_{syn} \gets \{\emptyset\}$ 
      \EndProcedure	
      \Procedure{MainLoop}{}
        \State $\textit{c} \gets nextValidState(\Gamma)$
        \If {$\nexists \text{ valid states in }\Gamma$}
          \State $\Omega_{syn} \gets \{\gamma \in \Gamma:\gamma.candidacy=True\}$
          \State \Return $\Omega_{syn}$
        \Else
          \State $\textit{l} \gets length(c.label)$
          \If {$\textit{l} < \textit{W}$}
            \State $\Lambda \gets \{\textit{s} \in \Delta : length(s) > l\}$
            \For{$\text{each } \lambda \in \Lambda$} 
              \If{$\textit{c.label}$ is a suffix of $\lambda$}
                \State $\textit{p} \gets \mathcal{V}(c(label)) = \mathcal{V}(h)$
                \If{$\textit{p} = False$}
                  \State c.candidacy = False
                  \State $expandTrees(c.label, \mathcal{S}, \mathcal{T}, \Gamma, \Delta, \Sigma)$
                  \State $\gamma.tested = False\text{ } \forall \gamma \in \Gamma$
                  \State \textbf{break}
                  \Else
                  \If{all elements in $\Lambda$ were tested}
                  	\State $c.tested = True$
                  \EndIf
                \EndIf
              \EndIf
            \EndFor
          \EndIf
          \State \textbf{goto} \emph{MAINLOOP}.
        \EndIf
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}
  
Algorithm \ref{alg:expand} will properly expand $\Gamma$ and $\Delta$ after a statistical test fails. First, the candidate for which the test failed is expanded in $\Delta$: its children are stored in a list called $\Phi$ and $\Delta$ is updated appending these new states. As the nodes in $\mathcal{S}$ have inverted labels in regard to $\mathcal{T}$, the components of $\Phi$ have their names inverted and stored in $\Upsilon$. For each element $\upsilon$ in $\Upsilon$, its shortest valid suffix in $\mathcal{S}$ is found and stored in $\eta$. To find the shortest valid suffix, the procedure described before to find a suffix is used and it stops when a state in $\mathcal{S}$ is found for which its \textit{candidacy} flag in $\Gamma$ is true. If the label of $\upsilon$ and $\eta$ are the same state, the list $\Pi$ receives all of the children of $\upsilon$. After repeating this process for all elements in $\Upsilon$, the updated $\Pi$ is appended to the list $\Delta$.

When Algorithm \ref{alg:expand} is called, the lists of tree elements are updated with the new nodes that will be needed for synchronization worda analysis.
  
  \begin{algorithm}
  \caption{expandTrees($c, \mathcal{S}, \mathcal{T}, \Gamma, \Delta, \Sigma$)\label{alg:expand}}
    \begin{algorithmic}[1]
      \Procedure{Expand Trees}{}
      	\State $\Phi \gets \{(\delta(c,\sigma), True, False), \text{ } \forall \sigma \in \Sigma\}$
        \State $\Gamma \gets \Gamma \cup \Phi$
        \State $\Upsilon \gets  \{invert(\phi.label), \forall \phi \in \Phi\}$
        \State $\Pi \gets \{\emptyset\}$
        \For{each $\upsilon$ in $\Upsilon$}
        	\State $\eta \gets$ shortest valid suffix of $\upsilon$ in $\mathcal{S}$
            \If{$\eta = \upsilon$}
            	\State $\Pi \gets \Pi\cup\{\delta(\upsilon,\sigma)\text{ }\forall \sigma \in \Sigma\}$
            \EndIf
        \EndFor
      \State $\Delta \gets \Delta \cup \Pi$
      \State \textbf{return}
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}

%
\subsection{An Example}

\section{Tree Termination}

\section{Graph Construction}
