\chapter{Códigos Corretores de Erros em Surto}\label{cap:codigos corretores de erros em surto}


{\lettrine[loversize=0.25,findent=0.2em,nindent=0em]{O}{s}
erros que atuam em sistemas de comunicação podem ser classificados como erros aleatórios e erros em surtos. No primeiro caso, cada dígito da sequência transmitida é afetado por ruído independentemente dos demais. Esse tipo de erro é comum em comunicações espaciais ~\cite{Livro:Shulin}. No entanto, alguns canais de comunicação como: linhas telefônicas ou sistemas de armazenamento magnético, podem inserir erros que afetem uma sequência de \emph{bits} da palavra código transmitida, nesse caso tem-se um erro em surto. Para atuar na correção de erros em surtos, foram desenvolvidos os chamados \emph{Códigos Corretores de Erros em Surto}. Códigos cíclicos foram utilizados ao longo de décadas para correção de erros em surto. Inicialmente estudados por Abramson \cite{art:Abramson} \cite{art:Abramson_Elspas} para a correção de surtos simples, seus estudos foram generalizados por Fire, originando os \emph{Fire Codes}, utilizados na correção de surtos múltiplos \cite{art:Fire}. À medida que o conhecimento na área aumentava, outros códigos cíclicos para erros em surto foram desenvolvidos e o seus desempenhos melhorados \cite {art:Stone} \cite{art:Meggitt-2} \cite{art:Chien}.

Nesta dissertação é feita uma abordagem geral sobre os códigos cíclicos. Ao longo do capítulo são abordadas as técnicas de correção para erros em surto por armadilha fixa e por armadilha adaptativa usando códigos cíclicos, exemplificando cada caso. Essas duas técnicas são utilizadas no auxílio à correção das manchas bidimensionais.

%%%%%%%%%%%%%%%%%%%%%% FIM DA SEÇÃO - INTRODUÇÃO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conceitos Básicos}\label{sec:conceitosbasicossurto}

Antes de determinar as condições para um código cíclico corrigir erros em surtos, há necessidade de definir o termo surto.

\begin{definition}[Surto]\label{def:surto}
Um surto de comprimento $b$ é uma sequência binária com $b$ bits consecutivos em que o primeiro e último não são nulos.
\end{definition}

O número de \emph{bits} não nulos em determinado vetor de comprimento qualquer é denotado por $p$ e conhecido como peso do vetor. No caso de surtos de comprimento $b$ tem-se $2 \leq p \leq b$.

\begin{example}
\label{ex:surto1}
$e=[0 1 1 0 1 0 0 0 0 0 0 0 0 0];$
Surto de comprimento $b=4$ e $p=3$.
\end{example}

\begin{example}
\label{ex:surto2}
$e=[1 1 0 0 0 0 0 0 0 0 0 1 0 0];$
Surto de comprimento $b=5$ e $p=3$.
\end{example}


Uma primeira inspeção do surto do Exemplo ~\ref{ex:surto2} é possível considerar que ele possui comprimento $b=12$. No entanto, ao se usar códigos cíclicos considera-se também os deslocamentos cíclicos do vetor. Ao realizar três deslocamentos para a direita do vetor $\mathbf{e}$ apresentado no Exemplo ~\ref{ex:surto2}, o surto fica com comprimento $b=5$. Esse menor valor é o adotado, pois admite-se que o surto atacou o fim e o começo do vetor ao mesmo tempo. Surtos desse tipo recebem o nome de surtos \emph{end-around}.

Uma caracterítica essencial de um código desenvolvido para correção de erros em surtos é o comprimento máximo do surto que o código é capaz de corrigir.

\begin{definition}[Código Corretor de Erros em Surtos] \label{def:codigocorrsurto}
Um código linear é dito código corretor de erros em surtos de comprimento $b$, ou tem capacidade $b$ de correção em erros em surtos se o código for capaz de corrigir todos os surtos de comprimento $b$ ou menor, mas nem todos os surtos de comprimento $b+1$.
\end{definition}

 Dado o código linear $C(n,k)$, existe uma relação entre os parâmetros do código e a sua capacidade de correção de erros em surto. A busca por códigos que agreguem menor redundância à informação é sempre desejada, para tal a seguinte teorema deve ser obedecido. Teorema 20.1,\cite{Livro:Shulin}.

\begin{theorem}[Parâmetros do Código Linear com capacidade b de correção de erros em surto]
O número de bits de reduntância $n$-$k$ para um código linear $C(n,k)$ com capacidade de correção de erros em surto $b$ deve ser maior ou igual a $2b$, isto é,

\begin{eqnarray} \label{eq:valordigparidade}
n-k &\geq & 2b.
\end{eqnarray}
\label{teoremacapsurto}
\end{theorem}

\begin{proof}
A prova para o Teorema ~\ref{teoremacapsurto} é composta de duas partes. Primeiramente é necessário provar que nenhum surto de comprimento $2b$ ou menor é uma palavra código e em seguida demonstrar que o número de bits de reduntância, $n$-$k$ deve ser maior ou igual a $l$, em que $l$-$1$ é o comprimento máximo de um surto que seja palavra código.

Considere a existência de um vetor $\mathbf{v}$ de comprimento $2b$ ou menor, com excessão do caso degenerado em que o comprimento é igual a $1$,  que seja uma palavra código. Este vetor pode ser expresso como uma soma de dois outros vetores $\mathbf{x}$ e $\mathbf{z}$ de comprimento $b$ ou menor. Os vetores $\mathbf{x}$ e $\mathbf{z}$ podem pertencer à mesma classe lateral no arranjo padrão, no entanto, se um desses vetores for usado como líder de uma classe lateral o outro será classificado como um erro intedectável. Sendo assim, o código não terá capacidade $b$ de correção para erros em surtos, pois existe um surto de comprimento $b$ ou menor que o código não é capaz de corrigir. Então, nenhum surto de comprimento $2b$ ou menor pode ser uma palavra código.

 Sejam os $2^l$ vetores cujas componentes não-nulas estão confinadas nas $l$ primeiras posições. Dois vetores desta classe não podem pertencer à mesma linha do arranjo padrão do código em questão. No entanto, a sua soma, que resulta num vetor de comprimento $l$ ou menor, pode ser uma palavra código. Dessa forma, esses $2^l$ vetores podem formar as $2^{n-k}$ classes laterais do código $C(n,k)$. Logo, $n-k \geq l$.

As duas partes desta prova resultam na prova do Teorema ~\ref{teoremacapsurto}, pois $l=2b$ e $n-k \geq l$.
\end{proof}

Do Teorema ~\ref{teoremacapsurto} é obtido um limitante superior para a capacidade de correção de surtos de determinado código linear $C(n,k)$ dado pela Inequação ~\ref{eq:limreiger}, chamado de limitante de Reiger \cite{art:Reiger}:

\begin{eqnarray} \label{eq:limreiger}
b &\leq & \left \lfloor \frac {n-k}{2} \right \rfloor.
\end{eqnarray}

Códigos que satisfazem o limitante de Reiger na igualdade são considerados códigos ótimos e com base nele foi desenvolvida uma taxa, representada na Fórmula ~\ref{eq:taxareiger}, usada como uma medida para determinar a eficiência na correção de surtos de determinado código

\begin{eqnarray} \label{eq:taxareiger}
z & = & \frac {2b}{n-k}.
\end{eqnarray}

A decodificação por armadilha consiste em aprisonar o erro em determinado número de estágios do registrador síndrome. Ela foi desenvolvida por Mitchell em 1962 \cite{art:Mitchell} e pode ser aplicada para a correção tanto de erros em surto quanto erros aleatórios. Inicialmente, é feita uma abordagem para erros aleatórios sobre a técnica, em seguida, ela é aplicada para os erros em surto.

Seja o código cíclico binário linear $C(n,k)$. Um polinômio código $v(x)$, codificado na forma sistemática, é transmitido e afetado pelo polinômio erro $e(x)$, resultando na recepção o polinômio $r(x)$. Seja $s(x)$ a síndrome de $r(x)$ de grau $n$-$k$-$1$ ou menor. Se os erros estiverem confinados nas $n$-$k$ posições de grau superior de $r(x)$, tem-se que $e(x)= e_{k}x^{k} + \ldots + e_{n-2}x^{n-2} + e_{n-1}x^{n-1}$. Após $n$-$k$ deslocamentos cíclicos de $e(x)$ encontra-se $e^{n-k}(x)$ que de acordo com  ~\ref{eq:relacaodesloc} é igual a $e^{n-k}(x) = e_kx^0 + e_{k+1}x^1 + \ldots + e_{n-2}x^{n-k-2} + e_{n-1}x^{n-k-1}$. Por sua vez $e^{n-k}(x)= s(x)^{n-k}$, em que $s(x)^{n-k}$ é a síndrome de $ r^{n-k}(x)$. Realizando a multiplicação de $x^k$ por $s(x)^{n-k}$, tem-se

\begin{eqnarray} \label{eq:sindrerr}
x^ks(x)^{n-k} & = & e(x).
\end{eqnarray}

 De ~\ref{eq:sindrerr} retira-se a informação para corrigir determinado padrão de erro $e(x)$ confinado nas $n$-$k$ posições de grau superior de $r(x)$. Dando continuidade, deve-se primeiro calcular a síndrome do vetor recebido. Em seguida, realizar os $n$-$k$ deslocamentos cíclicos necessários e, após a multiplicação por $x^k$ finalmente adicionar $x^ks(x)^{n-k}$ a $r(x)$. Esse polinômio resultante é considerado o polinômio código transmitido. Caso o erro não esteja localizado nas $n-k$ posições de maior grau de $r(x)$ mas, localizado em $n$-$k$ posições consecutivas de $r(x)$, inclusive erros \emph{end-around}. É possível, após um certo número de deslocamentos, confinar os erros nas $n$-$k$ posições de maior grau de $r(x)$ e assim poder efetuar a correção do erro. A seguir são apresentadas as técnicas de decodificação usadas na elaboração desta dissertação.


\section{Decodificação de Surtos Isolados Utilizando Códigos Cíclicos}

\subsection{Decodificação por armadilha fixa} \label{decodificacaofixa}

Para o caso de armadilha fixa considera-se uma armadilha de tamanho igual a $b$, em que o código $C(n,k)$ é um código corretor de erros em surtos de comprimento $b$. A idéia do algoritmo é, após o recebimento completo de $r(x)$ e cálculo do respectivo $s(x)$, realizar deslocamentos do conteúdo do registrador síndrome até aprisionar o surto na armadilha. Seja o código cíclico binário linear $C(n,k)$ com capacidade de correção de erros em surtos $b$. Um polinômio código $v(x)$, codificado na forma sistemática,  é transmitido e afetado pelo polinômio erro $e(x)$, resultando na recepção o polinômio $r(x)$. Seja $s(x)$ a síndrome de $r(x)$ de grau $n$-$k$-$1$ ou menor. Considere o surto confinado nas $b$ posições de grau superior da região de paridade de $r(x)$, isto é, $e(x)= e_{n-k-b}x^{n-k-b} + \ldots + e_{n-k-2}x^{n-k-2} + e_{n-k-1}x^{n-k-1}$. Para este caso, a sequência dos $b$ coeficientes de maior grau de $s(x)$ representa os \emph{bits} do padrão de erro $e(x)$ inserido e os demais coeficientes de $s(x)$ devem ser nulos. Logo, o surto foi aprisionado na armadilha do decodificador. Os erros também podem estar em $b$ posições consecutivas de $r(x)$, sendo do tipo \emph{end-around} ou não,  então, existe um número $i$ de deslocamentos que aprisiona o erro nas $b$ posições de ordem superior de $s^i(x)$, dessa forma possibilitando a correção do surto.

A Figura ~\ref{fig:figuradecfixo} ilustra o esquema do decodificador de armadilha simples. Em seguida o algoritmo para decodificação é apresentado.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{figura_decodificador_fixo.eps}
\caption{Circuito decodificador genérico por armadilha fixa para um código cíclico C(n,k).}
\label{fig:figuradecfixo}
\end{figure}


\begin{enumerate}
  \item Inicialmente todo o vetor $\mathbf{r}$ é recebido e armazenado no registrador de armazenamento. O mesmo vetor é usado no cálculo da síndrome que é armazenada no registrador síndrome com as chaves P1 e P3 ativas;
  \item São realizados $n$-$k$-$b$ deslocamentos do registrador síndrome com P3 ativa em busca de erros na região de paridade. A cada deslocamento é realizado o teste nos $n$-$k$-$b$ estágios a esquerda do registrador síndrome. Se em algum momento a soma desses estágios for nula então o erro está localizado na região de paridade. Isto implica que os $k$ dígitos de informação estão livres de erro e podem ser repassados com a ativação de P2. Caso não zere após esses $n$-$k$-$b$ deslocamentos o algoritmo segue para o Passo 3;
  \item Nesta etapa a busca é por surtos \emph{end-around} que ataquem ambas as regiões: de paridade e de informação. Se após $n$-$k$-$b$+$i$ deslocamentos para $1 \leq i \leq b$, zerar os $n$-$k$-$b$ dígitos à esquerda do registrador síndrome, então os dígitos contidos nos estágios $b$-$i$ mais à direita do registrador síndrome corrigem os dígitos $x^0, x^1, \ldots, x^{b-i-2}, x^{b-i-1}$ na região de paridade de $r(x)$. E os demais $i$ dígitos do registrador corrigem as posições $x^{n-i}, \ldots, x^{n-2}, x^{n-1}$ na região de informação de $r(x)$. Por meio de sincronização de relógio o registrador síndrome é deslocado com P3 desativada até o momento certo para que os \emph{bits} corrijam o surto inserido. No momento de sincronismo exato, as chaves P2 e P4 são ativadas e a correção é efetuada.  Caso o critério de zeramento não seja obedecido após esses $n$-$k$ deslocamentos o algoritmo segue para o Passo 4;
  \item Se após os $n$-$k$ deslocamentos ainda não for registrada a sequência de zeros desejada então, o circuito realiza mais $k$ deslocamentos para esvaziar os \emph{bits} de informação do registro de armazenameno com P2 ativa. Ao mesmo tempo, o registrador síndrome é deslocado com P3 ativa, sempre observando os $n$-$k$-$b$ estágios mais à esquerda do registrador síndrome. No momento em que esses estágios se anularem, P3 é desativada e os $b$ dígitos mais à direita do registrador síndrome corrigem os próximos $b$ dígitos que saírem do registro de armazenamento com P4 ativa.
\end{enumerate}

Se após os $n$ deslocamentos, os $n$-$k$-$b$ estágios à esquerda do registrador síndrome não conter apenas zeros significa que um padrão de erro incorrigível foi detectado. A seguir há um exemplo da atuação do decodificador por armadilha fixa na correção de erros em surtos.

\begin{example}
\label{ex:armadilhafixa}
Seja $C(15,5)$ o código cíclico binário corretor de erros em surtos de tamanho 5 gerado por $g(x)=1+x^2+x^5+x^6+x^8+x^9+x^{10}$. A Figura ~\ref{fig:armadilhasimples15} ilustra o circuito decodificador baseado na Figura ~\ref{fig:figuradecfixo}, em destaque os $n-k-b = 15-5-5 = 5$ estágios que determinam o fim do algoritmo.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15.eps}
\caption{Circuito decodificador para $g(x)=1+x^2+x^5+x^6+x^8+x^9+x^{10}$ do código cíclico C(15,5), em destaque os cinco estágios que determinam o fim do algoritmo.}
\label{fig:armadilhasimples15}
\end{figure}

Seja o polinômio $u(x)=0$ codificado sistematicamente originando $v(x)=0$. Este polinômio foi transmitido e o polinômio erro $e(x)=x^{10}+x^{11}+x^{12}+x^{14}$ adicionado a $v(x)$ resultando em $r(x)=x^{10}+x^{11}+x^{12}+x^{14}$. A representação vetorial de $r(x)$ $\mathbf{r}$ é carregado e a síndrome resultante é calculada conforme o Exemplo ~\ref{ex:excalcsind}, sendo assim, a \textbf{etapa 1} do algoritmo é finalizada.

As Figuras ~\ref{fig:correcaoarmad1} e ~\ref{fig:correcaoarmad11} ilustram cada deslocamento até a etapa dois do algoritmo.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p1.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p2.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p3.eps}
\caption{Estado inicial ao deslocamento 2 do registrador síndrome na correção por armadilha simples até a etapa 2 do algoritmo.}
\label{fig:correcaoarmad1}
\end{figure}
\newpage
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p4.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p5.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p6.eps}
\caption{Deslocamentos 3 ao 5 do registrador síndrome na correção por armadilha simples até a etapa 2 do algoritmo.}
\label{fig:correcaoarmad11}
\end{figure}

Até o momento realizaram-se os $n$-$k$-$l$=$5$ deslocamentos e não há apenas zeros nos estágios em destaque da Figura ~\ref{fig:correcaoarmad11}. Então, o algoritmo segue para o Passo três. As Figuras ~\ref{fig:correcaoarmad2} e ~\ref{fig:correcaoarmad21} ilustram cada deslocamento até o fim da etapa três do algoritmo.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p7.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p8.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p9.eps}
\end{figure}
\newpage
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p10.eps}
\caption{Deslocamentos 6 ao 9 do registrador síndrome na correção por armadilha simples até a etapa 3 do algoritmo.}
\label{fig:correcaoarmad2}
\end{figure}
\newpage
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p11.eps}
\caption{Deslocamento 10 do registrador síndrome do registrador síndrome na correção por armadilha simples até a etapa 3 do algoritmo.}
\label{fig:correcaoarmad21}
\end{figure}

Neste momento a condição de parada do algoritmo é satisfeita indicando que o erro está aprisionado na armadilha. Em seguida P3 é desligada e P2 e P4 ativadas para a correção do vetor recebido. As Figuras ~\ref{fig:correcaoarmad3} e ~\ref{fig:correcaoarmad31} ilustram a correção do vetor recebido \textbf{r}.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p12.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p13.eps}
\caption{Correção do vetor recebido - estado inicial e deslocamento 1.}
\label{fig:correcaoarmad3}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p14.eps}
\end{figure}
\newpage
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p15.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_simplescod15p16.eps}
\caption{Correção do vetor recebido - deslocamentos 2 a 4.}
\label{fig:correcaoarmad31}
\end{figure}

Após o completo esvaziamento do registro de armazenamento temos que o surto foi corrigido do vetor recebido \textbf{r}.
\end{example}

\subsection{Decodificação por armadilha adaptativa}\label{decodificacaoadaptativa}

Na decodificação por armadilha adaptativa, como o próprio nome induz, não há um tamanho determinado para a armadilha que aprisona o surto. Esta técnica se baseia no fato de que se determinado surto atacar a palavra código é mais provável que esse surto seja o de menor comprimento. Com este decodificador surtos com comprimento até $n$-$k$ podem ser corrigidos. O circuito para a decodificação por armadilha é basicamente o mesmo do apresentado na Figura ~\ref{fig:figuradecfixo} com a diferença de que não existe o teste por zeros nos $n$-$k$-$b$ estágios mais à esquerda do registrador síndrome. A armadilha vai se adaptando à medida que o algoritmo segue. A seguir apresenta-se o algoritmo para esta decodificação proposto por Gallager \cite{Livro:Gallager1}.

\begin{enumerate}
  \item Inicialmente, todos os coeficientes do polinômio $r(x)$ são recebidos e armazenados no re\-gis\-tra\-dor de armazenamento. O mesmo vetor é usado no cálculo da síndrome que é armazenada no registrador síndrome com P1 e P3 ativas;
  \item Em seguida, são realizados $n$ deslocamentos no registrador síndrome com P3 ativa. Em cada deslocamento é armazenado o tamanho da sequência de zeros a contar da extremidade direita do registrador síndrome, denotado por $j$. Também são armazenados o tamanho da armadilha para cada deslocamento dado por $A$ = $n$-$k$-$j$, bem como o número do deslocamento realizado e a sequência presente no registrador síndrome;
  \item No fim dos $n$ deslocamentos há um histórico com os valores de $A$ e cada sequência associada. O surto de menor comprimento está confinado nos $A'$ estágios mais à esquerda do registrador síndrome. Em que $A'$ corresponde ao menor valor de $A$ do histórico armazenado.
  \item Com o conhecimento do surto e do valor do deslocamento realizado o sincronismo é feito e realizado o deslocamento do vetor recebido até o momento em que o surto corrija os \emph{bits} afetados no vetor recebido com P2 e P4 ativadas.
\end{enumerate}

A seguir há um exemplo da atuação do decodificador por armadilha adaptativa na correção de erros em surtos.

\begin{example}
\label{ex:armadilhaadaptativa}
 Seja $C(15,5)$ o código cíclico binário corretor de erros em surtos de tamanho 5  gerado por $g(x)=1+x^2+x^5+x^6+x^8+x^9+x^{10}$. O circuito decodificador para este $g(x)$ é igual ao apresentado na Figura ~\ref{fig:armadilhasimples15} com a diferença de que não há preocupação com os estágios iniciais do registro síndrome.

Considerando os mesmos polinômios informação, código e recebido do Exemplo ~\ref{ex:armadilhafixa}, podemos dar início ao algoritmo para correção de armadilha adaptativa.

Segundo o algoritmo, é necessário realizar $n=15$ deslocamentos e analisar a cada deslocamento o tamanho da janela e o surto que ela armazena. A fim de não tornar repetitivo, já se considera os dez deslocamentos realizados no Exemplo ~\ref{ex:armadilhafixa}. As Figuras ~\ref{fig:correcaoarmad4} e ~\ref{fig:correcaoarmad5} ilustram os cinco deslocamentos restantes.

\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_adaptativa15p1.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_adaptativa15p2.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_adaptativa15p3.eps}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_adaptativa15p4.eps}
\caption{Deslocamentos finais do registrador síndrome para a decodificação por armadilha adaptativa.}
\label{fig:correcaoarmad4}
\end{figure}
\begin{figure}[!h]
\center
\includegraphics[scale=0.5]{armadilha_adaptativa15p5.eps}
\caption{Deslocamento final do registrador síndrome para a decodificação por armadilha adaptativa.}
\label{fig:correcaoarmad5}
\end{figure}

Após os quinze deslocamentos a Tabela ~\ref{tabelasdecodadap} é construída. Nela apresenta-se o tamanho de cada armadilha e o surto aprisionado por ela em cada deslocamento.

\begin{table}[!h]
\caption {Valor do tamanho da armadilha e o surto aprisionado para cada deslocamento.}
\begin{center}
\begin{tabular}{|c|c|c|} \hline
\textbf{Deslocamento} & \textbf{Tamanho da armadilha} (A) & \textbf{Surto aprisionado}\\ \hline

1 & 10 & 1 0 0 1 0 1 0 0 1 1  \\ \hline
2 & 9 & 1 1 1 0 1 1 0 0 1 0  \\ \hline
3 & 10 & 0 1 1 1 0 1 1 0 0 1  \\ \hline
4 & 10 & 1 0 0 1 1 1 0 1 1 1  \\ \hline
\textbf{5} & \textbf{5} & \textbf{1 1 1 0 1 0 0 0 0 0}  \\ \hline
6 & 6 & 0 1 1 1 0 1 0 0 0 0  \\ \hline
7 & 7 & 0 0 1 1 1 0 1 0 0 0  \\ \hline
8 & 8 & 0 0 0 1 1 1 0 1 0 0 \\ \hline
9 & 9 & 0 0 0 0 1 1 1 0 1 0  \\ \hline
10 & 10 & 0 0 0 0 0 1 1 1 0 1 \\ \hline
11 & 10 & 1 0 1 0 0 1 0 1 0 1  \\ \hline
12 & 10 & 1 1 1 1 0 1 0 0 0 1  \\ \hline
13 & 10 & 1 1 0 1 1 1 0 0 1 1  \\ \hline
14 & 9 & 1 1 0 0 1 0 0 0 1 0 \\ \hline
15 & 10 & 0 1 1 0 0 1 0 0 0 1  \\ \hline
\end{tabular}
\label{tabelasdecodadap}
\end{center}
\end{table}

\newpage A linha em negrito, corresponde ao quinto deslocamento e consiste no valor de $A'$, logo esta sequência é o surto considerado que corresponde à sequência dos coeficientes do polinômio erro inserido. Com o sincronismo dos deslocamentos dos registradores a correção é efetuada da mesma forma que nas Figuras ~\ref{fig:correcaoarmad3} e ~\ref{fig:correcaoarmad31}.

\end{example}

Após exemplificar os algoritmos, pode-se agora desenvolver a teoria para a correção de manchas bidimensionais.

%%%%%%%%%%%%%%%%%%%%%% FIM DA SEÇÃO - FIM DO CAPÍTULO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

